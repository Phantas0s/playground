1
00:00:00,499 --> 00:00:02,830
The following content is
provided under a Creative

2
00:00:02,830 --> 00:00:04,340
Commons license.

3
00:00:04,340 --> 00:00:06,680
Your support will help
MIT OpenCourseWare

4
00:00:06,680 --> 00:00:11,050
continue to offer high-quality
educational resources for free.

5
00:00:11,050 --> 00:00:13,670
To make a donation or
view additional materials

6
00:00:13,670 --> 00:00:17,565
from hundreds of MIT courses,
visit MIT OpenCourseWare

7
00:00:17,565 --> 00:00:18,190
at ocw.mit.edu.

8
00:00:22,387 --> 00:00:23,970
MARTEN VAN DIJK: So
today, we're going

9
00:00:23,970 --> 00:00:28,030
to talk about
communication networks.

10
00:00:28,030 --> 00:00:30,270
Communication networks
is a great application

11
00:00:30,270 --> 00:00:32,020
of graph theory.

12
00:00:32,020 --> 00:00:34,910
So what we're going
to study is, how

13
00:00:34,910 --> 00:00:38,030
do you route packets
through networks?

14
00:00:38,030 --> 00:00:40,900
So you have the internet,
which is a chaotic network.

15
00:00:40,900 --> 00:00:42,850
It's not organized.

16
00:00:42,850 --> 00:00:46,270
We are interested in
highly structured networks

17
00:00:46,270 --> 00:00:48,400
and you can find
them, for example,

18
00:00:48,400 --> 00:00:53,980
in parallel computers, where
you want to route the data flow.

19
00:00:53,980 --> 00:01:01,170
You can find them in certain
telephone switches networks

20
00:01:01,170 --> 00:01:02,620
and so on.

21
00:01:02,620 --> 00:01:06,920
So we are going to talk about
a few very special ones,

22
00:01:06,920 --> 00:01:09,870
binary trees, and then
slowly we will figure out

23
00:01:09,870 --> 00:01:12,960
what all these performance
measures really mean.

24
00:01:12,960 --> 00:01:14,400
This one has to do with latency.

25
00:01:14,400 --> 00:01:17,300
We have switches, their
size, the number of them,

26
00:01:17,300 --> 00:01:20,860
congestion, and then
we will slowly get down

27
00:01:20,860 --> 00:01:23,940
to Benes network, which is
a really beautiful network

28
00:01:23,940 --> 00:01:26,770
with beautiful parameters.

29
00:01:26,770 --> 00:01:29,510
And we are going to prove those.

30
00:01:29,510 --> 00:01:35,620
So let's start off with the
first one, the complete binary

31
00:01:35,620 --> 00:01:37,810
tree, and let me
draw it for you.

32
00:01:44,400 --> 00:01:49,930
In this network,
we will have a root

33
00:01:49,930 --> 00:01:57,410
and let me just draw it
first We have vertices that

34
00:01:57,410 --> 00:01:59,300
represent here the switches.

35
00:01:59,300 --> 00:02:04,370
So these circles-- let me
explain it over here-- actually

36
00:02:04,370 --> 00:02:07,120
represent a switch.

37
00:02:07,120 --> 00:02:15,040
And the idea is that these
actually direct packets

38
00:02:15,040 --> 00:02:16,140
through the network.

39
00:02:21,660 --> 00:02:25,430
And these packets are
fixed-size packets

40
00:02:25,430 --> 00:02:30,870
of data, so like, I don't
know, say 4,000 bytes or bits

41
00:02:30,870 --> 00:02:34,140
or whatever the network
wants you to comply to.

42
00:02:34,140 --> 00:02:38,090
So these are fixed-size
pieces of data.

43
00:02:38,090 --> 00:02:42,050
So what we want is we want to
be able from every terminal--

44
00:02:42,050 --> 00:02:45,500
and the terminal I will
denote by a square--

45
00:02:45,500 --> 00:02:47,710
from every terminal,
I want to be

46
00:02:47,710 --> 00:02:53,030
able to reach any
other terminal.

47
00:02:53,030 --> 00:02:54,040
So what is a terminal?

48
00:02:54,040 --> 00:02:58,610
A terminal is like a computer
or something like that.

49
00:02:58,610 --> 00:03:05,030
It's actually the source
and the destination of data.

50
00:03:12,880 --> 00:03:16,410
So what we are looking
for is how can we

51
00:03:16,410 --> 00:03:19,960
route-- how we can find
a network of switches

52
00:03:19,960 --> 00:03:22,980
that are connected through
wires, fibers, or-- yeah?

53
00:03:22,980 --> 00:03:24,129
What's the question?

54
00:03:24,129 --> 00:03:25,566
AUDIENCE: Can you
move down a bit

55
00:03:25,566 --> 00:03:27,961
the top of the-- how
it's getting cut off?

56
00:03:27,961 --> 00:03:28,919
No, the--

57
00:03:28,919 --> 00:03:29,710
That one.

58
00:03:29,710 --> 00:03:30,835
MARTEN VAN DIJK: Oh, sorry.

59
00:03:30,835 --> 00:03:32,272
AUDIENCE: All right.

60
00:03:32,272 --> 00:03:33,682
Thank you.

61
00:03:33,682 --> 00:03:35,140
MARTEN VAN DIJK:
So what we want is

62
00:03:35,140 --> 00:03:39,670
we want to route packets
that's come from any terminal

63
00:03:39,670 --> 00:03:41,320
to any other terminal.

64
00:03:41,320 --> 00:03:44,730
That is what our goal is
and we want to make sure

65
00:03:44,730 --> 00:03:47,080
that that is efficient.

66
00:03:47,080 --> 00:03:49,790
So the first one is
this binary tree.

67
00:03:49,790 --> 00:03:55,170
And let's see how this may work.

68
00:03:55,170 --> 00:04:06,060
We may have switches
that actually have

69
00:04:06,060 --> 00:04:08,245
inputs coming from terminals.

70
00:04:16,910 --> 00:04:21,060
And the switches may
also output to terminals,

71
00:04:21,060 --> 00:04:22,260
so here at the bottom.

72
00:04:22,260 --> 00:04:25,780
At this site, we have
a similar structure.

73
00:04:25,780 --> 00:04:27,510
this is the root of the tree.

74
00:04:27,510 --> 00:04:29,500
We have another
switch over here.

75
00:04:29,500 --> 00:04:35,260
We go down, we go up here,
and once more, like this.

76
00:04:35,260 --> 00:04:38,950
And again, we have-- oops.

77
00:04:38,950 --> 00:04:43,430
We have input coming in
or an output coming out

78
00:04:43,430 --> 00:04:44,685
to their respective terminals.

79
00:04:49,120 --> 00:04:52,910
So what is happening
here is that I

80
00:04:52,910 --> 00:04:59,570
would like to have an
input-- say input zero wants

81
00:04:59,570 --> 00:05:01,830
to travel all the
way over to say,

82
00:05:01,830 --> 00:05:04,280
the output that is
present over here.

83
00:05:04,280 --> 00:05:05,800
So let me label these.

84
00:05:05,800 --> 00:05:14,170
So we have the output zero,
input one, output one,

85
00:05:14,170 --> 00:05:23,940
input two and output two,
input three, and output four.

86
00:05:23,940 --> 00:05:29,100
So well, I can definitely
reach every single output

87
00:05:29,100 --> 00:05:31,470
from any input so that's great.

88
00:05:31,470 --> 00:05:34,540
So this looks like something
that you are familiar with,

89
00:05:34,540 --> 00:05:35,040
right?

90
00:05:35,040 --> 00:05:36,520
It's just a tree.

91
00:05:40,910 --> 00:05:42,870
It's a directed
graph, but these edges

92
00:05:42,870 --> 00:05:44,870
go in both directions, right?

93
00:05:44,870 --> 00:05:48,620
So I have an edge that goes from
here to here and back from here

94
00:05:48,620 --> 00:05:49,750
to here.

95
00:05:49,750 --> 00:05:53,840
So this is the kind of
layout that you could try out

96
00:05:53,840 --> 00:05:56,130
first to see whether
this type of network

97
00:05:56,130 --> 00:05:58,440
would lead to good performance.

98
00:05:58,440 --> 00:06:01,720
So let's have a look at
the different parameters

99
00:06:01,720 --> 00:06:04,670
and see how well this behaves.

100
00:06:04,670 --> 00:06:07,160
So here, we have
a few parameters

101
00:06:07,160 --> 00:06:09,100
that we will be talking about.

102
00:06:11,860 --> 00:06:16,390
So first of all, let's
talk about the latency

103
00:06:16,390 --> 00:06:18,690
in this particular network.

104
00:06:18,690 --> 00:06:21,680
So how are we going
to measure this?

105
00:06:21,680 --> 00:06:23,870
Well, we're going to
look at this graph

106
00:06:23,870 --> 00:06:26,650
and we're going to measure
it by the number of wires

107
00:06:26,650 --> 00:06:30,837
that you need to go through
from an input to an output.

108
00:06:30,837 --> 00:06:31,920
So let me write this down.

109
00:06:35,590 --> 00:06:48,520
So the latency is the time
that is required for a packet

110
00:06:48,520 --> 00:06:58,240
to travel from an
input to an output.

111
00:07:05,830 --> 00:07:08,087
And how are we going
to measure this?

112
00:07:08,087 --> 00:07:09,670
Well, we're just
going to measure this

113
00:07:09,670 --> 00:07:13,010
by the number of wires
that we need to go through.

114
00:07:13,010 --> 00:07:15,510
So this you have seen before.

115
00:07:15,510 --> 00:07:17,280
We can measure this
by the diameter

116
00:07:17,280 --> 00:07:19,330
of that particular graph.

117
00:07:19,330 --> 00:07:21,720
So here, we will define
it for a network.

118
00:07:21,720 --> 00:07:28,420
So the diameter of
a network is going

119
00:07:28,420 --> 00:07:46,700
to be the length of the
shortest path between the input

120
00:07:46,700 --> 00:07:56,950
and output that
are furthest apart.

121
00:07:56,950 --> 00:08:02,050
So let's have a look
at the graph above.

122
00:08:02,050 --> 00:08:07,270
So for example, we can clearly
see that, for example, input

123
00:08:07,270 --> 00:08:12,170
and output-- so say,
input zero and output one

124
00:08:12,170 --> 00:08:20,600
are connected by just going
up one step over here,

125
00:08:20,600 --> 00:08:24,370
but just going up
from here to here.

126
00:08:24,370 --> 00:08:27,880
Then, this switch forwards
the packet to this switch.

127
00:08:27,880 --> 00:08:31,740
This switch reroutes it,
forwards it over here,

128
00:08:31,740 --> 00:08:34,760
and then it goes back to
the output, output one.

129
00:08:34,760 --> 00:08:40,770
So for example, this particular
path only has 1, 2, 3, 4 edges.

130
00:08:40,770 --> 00:08:46,900
And what we are interested in
is sort of the worst-case time

131
00:08:46,900 --> 00:08:49,700
that it requires to go
from an input to an output.

132
00:08:49,700 --> 00:08:52,020
So that means that we are
interested in a diameter.

133
00:08:52,020 --> 00:08:56,590
And a diameter is in this
case, well, the shortest path

134
00:08:56,590 --> 00:09:01,560
that you can find from an input
to an output that are furthest

135
00:09:01,560 --> 00:09:02,060
apart.

136
00:09:02,060 --> 00:09:04,340
So what are those who
are furthest apart?

137
00:09:04,340 --> 00:09:06,780
Well, of course, you would
like to go through here, right?

138
00:09:06,780 --> 00:09:10,695
So if I connect the input
zero to say, output four,

139
00:09:10,695 --> 00:09:14,450
I will need to go all the
way up through the route

140
00:09:14,450 --> 00:09:16,400
down to the output.

141
00:09:16,400 --> 00:09:18,520
And how many edges
do we see here?

142
00:09:18,520 --> 00:09:23,530
1, 2, 3, 4, 5, 6--
so in this example,

143
00:09:23,530 --> 00:09:28,820
we have a diameter
that is equal to six.

144
00:09:28,820 --> 00:09:35,480
And in general, if you are
looking at n times n networks,

145
00:09:35,480 --> 00:09:37,030
what does it mean?

146
00:09:37,030 --> 00:09:41,390
n is the number of inputs and n
is also the number of outputs.

147
00:09:41,390 --> 00:09:45,600
So in this case, we have
a four times-- well,

148
00:09:45,600 --> 00:09:48,760
this is actually
three over here--

149
00:09:48,760 --> 00:09:52,180
we have four inputs
and four outputs.

150
00:09:52,180 --> 00:09:54,780
So this particular example
depicted on the board

151
00:09:54,780 --> 00:09:57,680
is a four times four network.

152
00:09:57,680 --> 00:10:03,730
So if you generalize this
for any size binary tree,

153
00:10:03,730 --> 00:10:09,190
say, an n times n
network, then what's

154
00:10:09,190 --> 00:10:12,380
the diameter of such
a general network?

155
00:10:12,380 --> 00:10:16,980
Well, if we have n
inputs and n outputs,

156
00:10:16,980 --> 00:10:19,170
well, we have to
go all the way up

157
00:10:19,170 --> 00:10:22,270
through towards the root
and all the way down.

158
00:10:22,270 --> 00:10:27,030
So we actually count the
length of a leaf to the root

159
00:10:27,030 --> 00:10:28,940
here twice.

160
00:10:28,940 --> 00:10:33,010
So in general, we have a
diameter that looks like this.

161
00:10:33,010 --> 00:10:39,740
It's 2 times 1 plus
the logarithm of n.

162
00:10:39,740 --> 00:10:48,550
So in this lecture, we will have
n is going to be a power of 2,

163
00:10:48,550 --> 00:10:51,030
just to make
calculations simple.

164
00:10:51,030 --> 00:10:56,170
And the logarithm is
always to the base two.

165
00:10:56,170 --> 00:11:01,330
So this is a diameter of
a general binary tree.

166
00:11:01,330 --> 00:11:05,460
And well, what are
the other parameters?

167
00:11:05,460 --> 00:11:07,320
So that does not look too bad.

168
00:11:07,320 --> 00:11:08,700
It's logarithmic in answer.

169
00:11:08,700 --> 00:11:10,420
That sounds pretty good.

170
00:11:10,420 --> 00:11:14,010
What about the switch sizes?

171
00:11:14,010 --> 00:11:16,400
Well, how do I measure those?

172
00:11:16,400 --> 00:11:18,615
It's like the number of
inputs that get into it

173
00:11:18,615 --> 00:11:20,240
and the number of
outputs that get out.

174
00:11:20,240 --> 00:11:24,600
So in this case, I will
have 1, 2 inputs that

175
00:11:24,600 --> 00:11:28,150
go into this switch and there
are two outputs coming out.

176
00:11:28,150 --> 00:11:31,290
So this is what we call
a two times two switch.

177
00:11:31,290 --> 00:11:33,600
So this will be a
two times two switch.

178
00:11:33,600 --> 00:11:35,630
But if you look at
this one, for example,

179
00:11:35,630 --> 00:11:41,950
we see one, two, three outgoing
edges and three ingoing edges.

180
00:11:41,950 --> 00:11:45,480
So this is actually a
three times three switch.

181
00:11:45,480 --> 00:11:49,970
And in a general
binary tree, we will

182
00:11:49,970 --> 00:11:53,060
see that all these intermediate
nodes over here, they

183
00:11:53,060 --> 00:11:54,660
are all three times
three switches.

184
00:11:54,660 --> 00:12:00,150
So approximately
half of the switches

185
00:12:00,150 --> 00:12:04,300
are actually three
times three switches.

186
00:12:04,300 --> 00:12:05,485
So that's the switch size.

187
00:12:10,350 --> 00:12:13,680
Now, you may say,
well, why don't I

188
00:12:13,680 --> 00:12:16,310
use a larger-sized switch?

189
00:12:16,310 --> 00:12:18,200
That would help me a lot, right?

190
00:12:18,200 --> 00:12:24,400
If I could use, say, a four
times four switch, then

191
00:12:24,400 --> 00:12:27,200
I would be able to have
more inputs coming in,

192
00:12:27,200 --> 00:12:30,770
more outputs coming
out, and I can actually

193
00:12:30,770 --> 00:12:34,070
maybe use a ternary tree
rather than a binary tree.

194
00:12:34,070 --> 00:12:37,260
In a binary tree,
every note at the level

195
00:12:37,260 --> 00:12:39,230
has two children, right?

196
00:12:39,230 --> 00:12:41,430
But we could design
a tree that has

197
00:12:41,430 --> 00:12:44,070
at every level three children.

198
00:12:44,070 --> 00:12:46,580
So then, they can use
four times four switches.

199
00:12:46,580 --> 00:12:51,220
But if you do that, then
the path from the leaf

200
00:12:51,220 --> 00:12:53,150
up to the root is
getting shorter

201
00:12:53,150 --> 00:12:54,780
and the diameter gets smaller.

202
00:12:54,780 --> 00:12:58,936
So if I increase the
switch size-- so rather

203
00:12:58,936 --> 00:13:00,810
than three times three,
we look at four times

204
00:13:00,810 --> 00:13:03,930
four or five times five, six
times six and so on-- then

205
00:13:03,930 --> 00:13:07,410
the diameter will
actually reduce.

206
00:13:07,410 --> 00:13:13,170
So what about having a monster
switch, like I have just one

207
00:13:13,170 --> 00:13:16,500
switch and I have my
input zero all the way up

208
00:13:16,500 --> 00:13:22,060
to input n minus 1 and
then I have my outputs

209
00:13:22,060 --> 00:13:22,810
on the other side?

210
00:13:28,960 --> 00:13:34,180
Well, of course, the
switch size is n times n

211
00:13:34,180 --> 00:13:37,320
but the diameter
is nothing, right?

212
00:13:40,400 --> 00:13:42,170
The diameter is reduced to one.

213
00:13:42,170 --> 00:13:44,230
You can immediately go
from an input to an output

214
00:13:44,230 --> 00:13:45,490
through the switch.

215
00:13:45,490 --> 00:13:47,240
But this, of course,
conceals the problem.

216
00:13:47,240 --> 00:13:50,510
So what we are interested
in is, well, we're

217
00:13:50,510 --> 00:13:53,960
actually really
interested in how

218
00:13:53,960 --> 00:13:56,900
to solve the problem of
routing all these inputs

219
00:13:56,900 --> 00:14:03,860
to these outputs using
smaller switches of size three

220
00:14:03,860 --> 00:14:05,800
times three or two times two.

221
00:14:05,800 --> 00:14:07,990
What we're really
interested in is,

222
00:14:07,990 --> 00:14:11,800
what is the internal structure
in this monster switch?

223
00:14:11,800 --> 00:14:14,450
I sort of have concealed the
problem by just saying, oh,

224
00:14:14,450 --> 00:14:15,990
I've got a big switch.

225
00:14:15,990 --> 00:14:20,190
But what we want
to solve today is

226
00:14:20,190 --> 00:14:25,640
how do we do the routing in this
case within the monster switch?

227
00:14:25,640 --> 00:14:30,780
So we want to use just
small switch sizes

228
00:14:30,780 --> 00:14:33,920
and build up a network
using these smaller ones,

229
00:14:33,920 --> 00:14:37,045
like three times three switches
or two times two switches.

230
00:14:39,950 --> 00:14:49,990
Now, so that brings us
to yet another parameter,

231
00:14:49,990 --> 00:14:52,240
because here, we'd like to
count the number or smaller

232
00:14:52,240 --> 00:14:54,490
switches that we
use and that relates

233
00:14:54,490 --> 00:14:58,570
to the cost of the network,
the amount of hardware

234
00:14:58,570 --> 00:15:00,100
that you need to put into it.

235
00:15:00,100 --> 00:15:06,145
So in this example, we
have the switch count.

236
00:15:09,477 --> 00:15:10,810
Well, it's pretty simple, right?

237
00:15:10,810 --> 00:15:16,920
It's 1, 2, 3, 4, 5, 6, 7--
we have seven switches.

238
00:15:16,920 --> 00:15:23,960
And in general, if we
have n inputs-- so 1,

239
00:15:23,960 --> 00:15:27,030
2, 3, 4 inputs-- then
the number of switches

240
00:15:27,030 --> 00:15:30,220
that we use in the binary
tree is 2 times the number

241
00:15:30,220 --> 00:15:33,680
of inputs minus 1.

242
00:15:33,680 --> 00:15:36,590
So let's write that down.

243
00:15:36,590 --> 00:15:40,080
So over here, we would
have 2 times n minus 1,

244
00:15:40,080 --> 00:15:42,330
which is the number of
switches that you actually use.

245
00:15:45,140 --> 00:15:47,360
So how can you
see that actually?

246
00:15:47,360 --> 00:15:57,310
So in general, we have 1 plus 2
plus 4 plus 8 and so on plus n.

247
00:15:57,310 --> 00:16:00,650
And it's a power of 2,
according to our assumptions.

248
00:16:00,650 --> 00:16:04,690
And if you add them all
up, I think you'll-- well,

249
00:16:04,690 --> 00:16:07,340
you can check for yourself that
this is actually equal to 2

250
00:16:07,340 --> 00:16:08,510
times n minus 1.

251
00:16:11,440 --> 00:16:13,260
So now, we have the switches.

252
00:16:13,260 --> 00:16:16,280
So so far, this looks
pretty good, actually.

253
00:16:16,280 --> 00:16:18,060
We use small switch sizes.

254
00:16:18,060 --> 00:16:21,440
The number of switches
is linear in n.

255
00:16:21,440 --> 00:16:24,430
The diameter is logarithmic
in n so that sounds good.

256
00:16:24,430 --> 00:16:25,780
So what about congestion?

257
00:16:25,780 --> 00:16:30,850
Do you any idea-- what's
the problem with this graph?

258
00:16:30,850 --> 00:16:34,700
What is the big,
big problem here?

259
00:16:34,700 --> 00:16:39,040
What can happen in a very
sort of worst-case scenario

260
00:16:39,040 --> 00:16:42,150
where the packets get routed
from inputs to the outputs?

261
00:16:42,150 --> 00:16:46,400
If they need to go
to certain locations,

262
00:16:46,400 --> 00:16:50,160
then they all may have to
travel through the root.

263
00:16:50,160 --> 00:16:52,620
So you get congestion over here.

264
00:16:52,620 --> 00:16:54,190
We don't like that.

265
00:16:54,190 --> 00:16:56,270
So this root is actually
then overloaded.

266
00:16:56,270 --> 00:16:59,640
Actually, you can
already see that say,

267
00:16:59,640 --> 00:17:04,500
this particular switch-- if this
switch fails, then actually,

268
00:17:04,500 --> 00:17:08,089
we will have two disjoint trees
that cannot even communicate

269
00:17:08,089 --> 00:17:09,490
to one another.

270
00:17:09,490 --> 00:17:15,349
So this brings us to
the idea of congestion.

271
00:17:15,349 --> 00:17:18,876
And in order to
define it better,

272
00:17:18,876 --> 00:17:20,209
you will need a few definitions.

273
00:17:24,210 --> 00:17:31,640
So to start, we will
define a permutation

274
00:17:31,640 --> 00:17:38,670
and we will use this to
stipulate the requirement

275
00:17:38,670 --> 00:17:43,130
that we want on how inputs
and outputs are related

276
00:17:43,130 --> 00:17:48,470
to another, which input needs
to communicate to which output.

277
00:17:48,470 --> 00:18:00,010
So permutation is a function
pi from the set 0 to n minus 1

278
00:18:00,010 --> 00:18:03,750
to the same set.

279
00:18:03,750 --> 00:18:15,880
And it is such
that no two numbers

280
00:18:15,880 --> 00:18:21,210
are mapped to more than once.

281
00:18:21,210 --> 00:18:26,050
So no two numbers are
mapped to the same value.

282
00:18:31,790 --> 00:18:34,760
So what we really want--
to put it in mathematics,

283
00:18:34,760 --> 00:18:41,600
we want that pi of i is
only equal to pi of j

284
00:18:41,600 --> 00:18:46,560
if and only if i is equal to j.

285
00:18:46,560 --> 00:18:52,480
So let's have an example to plug
into that picture over there.

286
00:18:52,480 --> 00:19:02,600
So a first example could be
pi of i equals, say, n minus 1

287
00:19:02,600 --> 00:19:03,230
minus i.

288
00:19:03,230 --> 00:19:05,880
This is a proper permutation.

289
00:19:05,880 --> 00:19:08,170
No two numbers map
to the same value.

290
00:19:08,170 --> 00:19:11,240
Another one could be the
identity permutation,

291
00:19:11,240 --> 00:19:15,730
like you map i to the same i.

292
00:19:15,730 --> 00:19:17,400
So that's another example.

293
00:19:17,400 --> 00:19:20,640
Now, how do we use
permutations to go

294
00:19:20,640 --> 00:19:22,310
towards the idea of congestion?

295
00:19:22,310 --> 00:19:26,569
So permutation can be used
to formulate the permutation

296
00:19:26,569 --> 00:19:27,235
routing problem.

297
00:19:29,860 --> 00:19:36,620
And the permutation routing
problem is defined like this.

298
00:19:42,170 --> 00:19:44,490
It's defined as follows.

299
00:19:44,490 --> 00:19:49,210
What we want is
that for each i, we

300
00:19:49,210 --> 00:20:04,940
want to direct the packet at
input i to output pi of i.

301
00:20:04,940 --> 00:20:07,166
So you want to do
that for all i.

302
00:20:07,166 --> 00:20:11,320
So let's have a look at this
particular example, where we

303
00:20:11,320 --> 00:20:13,700
look at identity permutation.

304
00:20:13,700 --> 00:20:19,150
So if you do that, we can
easily route this, right?

305
00:20:19,150 --> 00:20:23,610
So I want to send a packet
from input zero to output zero.

306
00:20:23,610 --> 00:20:27,040
So I can simply go
into this direction.

307
00:20:27,040 --> 00:20:28,770
I just go towards
this switch and it

308
00:20:28,770 --> 00:20:31,580
gets routed back to this one.

309
00:20:31,580 --> 00:20:38,170
I can go like this and
this one can go like this

310
00:20:38,170 --> 00:20:40,630
and this one goes like that.

311
00:20:40,630 --> 00:20:42,530
Now, if you look at
the other permutation,

312
00:20:42,530 --> 00:20:45,340
the picture looks
very different.

313
00:20:45,340 --> 00:20:53,200
Now, we want to route
input zero to output three.

314
00:20:53,200 --> 00:20:55,450
In order to do this,
I will actually

315
00:20:55,450 --> 00:21:04,660
need to go all the way through
here and then all the way down

316
00:21:04,660 --> 00:21:07,420
to this particular output.

317
00:21:07,420 --> 00:21:12,410
And now, the picture gets into a
big mess because for input one,

318
00:21:12,410 --> 00:21:16,600
we have to go to output two.

319
00:21:16,600 --> 00:21:20,500
So for input one, well, we
go all the way like this,

320
00:21:20,500 --> 00:21:23,210
we again go through
the root, and then

321
00:21:23,210 --> 00:21:28,740
we go down to this
particular output.

322
00:21:28,740 --> 00:21:32,620
And as you can see,
for input two, well,

323
00:21:32,620 --> 00:21:34,710
we need to connect
to output one.

324
00:21:34,710 --> 00:21:38,910
So again, we go all the way
up and we go all the way down.

325
00:21:38,910 --> 00:21:42,560
And for this one, we will
again go all the way up and all

326
00:21:42,560 --> 00:21:44,520
the way down to input zero.

327
00:21:44,520 --> 00:21:48,950
So now, you can see that this
particular switch over here

328
00:21:48,950 --> 00:21:55,110
has to serve packets
from all the inputs.

329
00:21:55,110 --> 00:21:57,650
All the four packets
have to travel

330
00:21:57,650 --> 00:22:00,160
through this
particular node here.

331
00:22:00,160 --> 00:22:03,490
So this leads us to the
following definition

332
00:22:03,490 --> 00:22:05,310
of congestion.

333
00:22:05,310 --> 00:22:14,940
So the congestion--
oh, before we continue,

334
00:22:14,940 --> 00:22:18,240
let me first define a path.

335
00:22:18,240 --> 00:22:23,300
So for i, we direct a packet
at input i to output pi of i.

336
00:22:23,300 --> 00:22:27,010
And the path that
corresponds to this route

337
00:22:27,010 --> 00:22:31,400
is actually denoted as follows.

338
00:22:31,400 --> 00:22:48,260
So the path taken is
denoted by P i pi i.

339
00:22:48,260 --> 00:22:50,740
So now, we can
define the congestion

340
00:22:50,740 --> 00:22:52,170
of a set of such paths.

341
00:22:52,170 --> 00:23:00,750
So the congestion of the
path corresponding to P zero

342
00:23:00,750 --> 00:23:04,480
to P pi zero and so on
and we go all the way up

343
00:23:04,480 --> 00:23:08,590
to the n minus 1
input that needs to be

344
00:23:08,590 --> 00:23:11,680
mapped to pi of n minus 1.

345
00:23:11,680 --> 00:23:23,910
So the congestion is now
defined as the largest

346
00:23:23,910 --> 00:23:43,650
number of paths that pass
through a single switch.

347
00:23:43,650 --> 00:23:50,330
So in our example, we saw that
in the case of the blue arrows

348
00:23:50,330 --> 00:23:53,520
here for the
identity permutation,

349
00:23:53,520 --> 00:23:58,320
well, this switch only
needs to transmit one packet

350
00:23:58,320 --> 00:24:00,550
and all those
actually zero packets.

351
00:24:00,550 --> 00:24:11,080
So actually, the congestion
here is equal to 1.

352
00:24:11,080 --> 00:24:14,370
And for this
particular permutation,

353
00:24:14,370 --> 00:24:18,260
well, we had to direct all
the packets through the root

354
00:24:18,260 --> 00:24:21,470
and it's the most
accessed switch.

355
00:24:21,470 --> 00:24:24,830
And that switch has
congestion four, right?

356
00:24:24,830 --> 00:24:31,850
So the congestion over
here is equal to 4.

357
00:24:34,520 --> 00:24:39,080
Now, this does not look so
good because for a binary tree,

358
00:24:39,080 --> 00:24:41,915
we always have this
vulnerable root that

359
00:24:41,915 --> 00:24:45,380
is right here in the center
connecting the left side

360
00:24:45,380 --> 00:24:46,420
to the right side.

361
00:24:46,420 --> 00:24:48,378
So we can always find a
permutation-- actually,

362
00:24:48,378 --> 00:24:50,680
this permutation over
here-- that leads

363
00:24:50,680 --> 00:24:54,110
to this worst-case congestion.

364
00:24:54,110 --> 00:24:59,470
So what we're interested in
is the maximum congestion,

365
00:24:59,470 --> 00:25:02,520
which is sort of the
worst-case scenario.

366
00:25:02,520 --> 00:25:09,150
And we'll define it as follows.

367
00:25:09,150 --> 00:25:11,720
The maximum
congestion is actually

368
00:25:11,720 --> 00:25:16,450
equal to the maximum
over all permutations pi.

369
00:25:16,450 --> 00:25:19,840
So this is kind of the
worst-case routing problem

370
00:25:19,840 --> 00:25:23,180
that I can imagine and
it may occur in practice.

371
00:25:23,180 --> 00:25:28,950
So in the worst case, how
can I solve it the best?

372
00:25:28,950 --> 00:25:37,440
So I want to find the
minimum of the congestion

373
00:25:37,440 --> 00:25:49,010
of a path over here
and the minimum

374
00:25:49,010 --> 00:25:50,750
is over these types of paths.

375
00:25:50,750 --> 00:25:54,840
So actually, this
is our solution

376
00:25:54,840 --> 00:25:56,480
to this routing problem.

377
00:25:56,480 --> 00:25:58,740
We want to find the
best kind of solution

378
00:25:58,740 --> 00:26:05,950
for this worst-case
scenario-- so

379
00:26:05,950 --> 00:26:18,750
the minimum over all
solutions for these paths

380
00:26:18,750 --> 00:26:25,420
So well, for this
particular tree structure,

381
00:26:25,420 --> 00:26:30,040
this permutation is really
the worst-case scenario

382
00:26:30,040 --> 00:26:33,150
that you can have because
every packet needs to be routed

383
00:26:33,150 --> 00:26:35,700
through the center over here.

384
00:26:35,700 --> 00:26:39,520
And it means that our maximum
congestion for an arbitrary

385
00:26:39,520 --> 00:26:42,310
tree is actually equal to n.

386
00:26:44,960 --> 00:26:49,950
So that looks really
bad, actually.

387
00:26:49,950 --> 00:26:53,650
So we don't like this at all.

388
00:26:53,650 --> 00:26:56,960
So let's find out where we
can do a little bit better

389
00:26:56,960 --> 00:27:01,350
and we come to look at
the two-dimensional array

390
00:27:01,350 --> 00:27:05,770
and see what that
would lead up to.

391
00:27:05,770 --> 00:27:09,755
And its structure is as follows.

392
00:27:13,920 --> 00:27:17,950
We essentially have
inputs on the left

393
00:27:17,950 --> 00:27:20,910
and the outputs
are on the bottom

394
00:27:20,910 --> 00:27:23,280
and they are in
a grid structure.

395
00:27:23,280 --> 00:27:30,700
So we have input zero, input
one, input two, input three.

396
00:27:30,700 --> 00:27:32,225
They all connect
to their terminals.

397
00:27:35,660 --> 00:27:44,810
We have switches, four of
those, and they are all

398
00:27:44,810 --> 00:27:46,320
connected in this grid.

399
00:27:49,660 --> 00:27:55,415
And at the very bottom, we will
have the outputs, the output

400
00:27:55,415 --> 00:27:55,915
terminals.

401
00:28:08,580 --> 00:28:12,730
So this is output
zero and here, we

402
00:28:12,730 --> 00:28:17,720
will have output one, output
two, and output three.

403
00:28:23,000 --> 00:28:27,000
So notice that my circle
start to resemble my squares,

404
00:28:27,000 --> 00:28:30,630
but these are all the switches
right here in the center.

405
00:28:30,630 --> 00:28:32,650
So how does this work?

406
00:28:32,650 --> 00:28:37,300
Well, do we have a
better parameter?

407
00:28:37,300 --> 00:28:39,280
So let's look at it together.

408
00:28:39,280 --> 00:28:41,890
So we need to
first of all figure

409
00:28:41,890 --> 00:28:43,390
out what the diameter is.

410
00:28:43,390 --> 00:28:48,310
So what's the diameter of
this particular network?

411
00:28:48,310 --> 00:28:54,750
So what's the shortest path
between the furthest input

412
00:28:54,750 --> 00:28:56,860
and output?

413
00:28:56,860 --> 00:28:59,880
So if you look at
that, we can see

414
00:28:59,880 --> 00:29:02,530
that if I go all
the way from here

415
00:29:02,530 --> 00:29:05,050
and I go all the way
down to this corner,

416
00:29:05,050 --> 00:29:07,770
that looks like the
largest path and I

417
00:29:07,770 --> 00:29:11,530
need to cross all these wires.

418
00:29:11,530 --> 00:29:16,100
And in general, for
any n, we will have

419
00:29:16,100 --> 00:29:20,760
that the diameter is 2 times n.

420
00:29:20,760 --> 00:29:23,629
Now, what about the switch size?

421
00:29:23,629 --> 00:29:25,170
It looks a little
bit smaller, right?

422
00:29:25,170 --> 00:29:27,530
Because over here, we had
three inputs coming in

423
00:29:27,530 --> 00:29:31,140
and three outputs coming
out but over here,

424
00:29:31,140 --> 00:29:33,030
we see that every
single switch is only

425
00:29:33,030 --> 00:29:35,270
two inputs and two outputs.

426
00:29:35,270 --> 00:29:38,440
So that makes the
size two times two.

427
00:29:41,950 --> 00:29:44,590
Now, the number of switches
is pretty bad, right,

428
00:29:44,590 --> 00:29:49,140
because we have n
squared switches.

429
00:29:49,140 --> 00:29:50,790
So that's really horrible.

430
00:29:50,790 --> 00:29:52,100
That's a lot.

431
00:29:52,100 --> 00:29:54,330
We would like to do much better.

432
00:29:54,330 --> 00:29:56,270
And what about the congestion?

433
00:29:56,270 --> 00:29:58,960
Do you have any idea
what the congestion could

434
00:29:58,960 --> 00:30:00,450
be in this particular case?

435
00:30:00,450 --> 00:30:03,020
We will prove a theorem on that.

436
00:30:07,190 --> 00:30:11,990
For any permutation,
is there a way to route

437
00:30:11,990 --> 00:30:15,060
the inputs to the outputs in
such a way that the switches

438
00:30:15,060 --> 00:30:17,790
get almost not congested?

439
00:30:17,790 --> 00:30:19,640
So in the binary tree,
we had a congestion

440
00:30:19,640 --> 00:30:23,080
of n, which is linear
in the switches.

441
00:30:23,080 --> 00:30:26,780
But over here, we
can do much better.

442
00:30:26,780 --> 00:30:45,210
We will show that the
congestion of an n-input array

443
00:30:45,210 --> 00:30:47,700
is actually equal to 2.

444
00:30:47,700 --> 00:30:49,590
So that's great.

445
00:30:49,590 --> 00:30:52,230
So I'll prove it in
a moment, but that

446
00:30:52,230 --> 00:30:53,960
looks really fantastic.

447
00:30:53,960 --> 00:30:58,930
And so it's way better
than the binary tree.

448
00:30:58,930 --> 00:31:02,030
Now, this is really not so good
and this is also much larger,

449
00:31:02,030 --> 00:31:09,440
but still-- we will
start to think next

450
00:31:09,440 --> 00:31:12,590
after we show this
particular property how

451
00:31:12,590 --> 00:31:15,770
to combine these two and
see how we can come up

452
00:31:15,770 --> 00:31:20,670
with another network that's
able to combine in some ways

453
00:31:20,670 --> 00:31:22,130
these two properties.

454
00:31:22,130 --> 00:31:25,107
And maybe we can find a
good solution that way.

455
00:31:25,107 --> 00:31:27,440
It turns out we will not
immediately be able to do that.

456
00:31:27,440 --> 00:31:29,310
We will need to
make another step

457
00:31:29,310 --> 00:31:31,700
and come to the last network.

458
00:31:31,700 --> 00:31:34,330
It really has good parameters.

459
00:31:34,330 --> 00:31:36,500
So what about the theorem?

460
00:31:36,500 --> 00:31:40,930
So if you prove this,
well, how do we start?

461
00:31:40,930 --> 00:31:44,627
You just start with
any permutation.

462
00:31:44,627 --> 00:31:46,710
If I want to prove something
about the congestion,

463
00:31:46,710 --> 00:31:49,775
it's defined as the maximum
of all permutations.

464
00:31:49,775 --> 00:31:53,670
So let's take one of them
and see what we can prove.

465
00:32:07,359 --> 00:32:11,305
So let us define the paths
for this permutation.

466
00:32:11,305 --> 00:32:14,530
So what we really want to do
is we take any permutation

467
00:32:14,530 --> 00:32:17,700
and we want to find a really
good solution for the routing.

468
00:32:17,700 --> 00:32:22,500
If that gives us a very low
congestion, we are very happy.

469
00:32:22,500 --> 00:32:28,270
So the way to do this is well,
maybe you have an idea already.

470
00:32:28,270 --> 00:32:30,120
So how would I route this?

471
00:32:30,120 --> 00:32:34,900
So I want to connect
an input i, say, 1, 2,

472
00:32:34,900 --> 00:32:38,580
output two, for example.

473
00:32:38,580 --> 00:32:39,680
How can I do this?

474
00:32:39,680 --> 00:32:41,640
Any suggestions?

475
00:32:41,640 --> 00:32:44,070
So of course, I
could go any path,

476
00:32:44,070 --> 00:32:48,000
but somehow, I want to have
some uniform structure that

477
00:32:48,000 --> 00:32:51,190
hopefully helps me to prove that
the congestion in every switch

478
00:32:51,190 --> 00:32:52,260
is very small.

479
00:32:52,260 --> 00:32:56,520
So how could I think about this?

480
00:32:56,520 --> 00:33:03,100
Well, if I make sure
that, say, a packet that

481
00:33:03,100 --> 00:33:06,230
goes from one to
output two is only

482
00:33:06,230 --> 00:33:09,400
going to be participating
in the wires

483
00:33:09,400 --> 00:33:15,510
off the i-th throw
and the P-i-th column,

484
00:33:15,510 --> 00:33:24,120
then I know that every wire will
only get traveled over twice

485
00:33:24,120 --> 00:33:24,780
by a packet.

486
00:33:24,780 --> 00:33:29,160
This could either be a packet
that goes into this direction

487
00:33:29,160 --> 00:33:32,650
or-- so a switch will be
accessed at most twice.

488
00:33:32,650 --> 00:33:36,160
A switch can either receive
a packet from this direction

489
00:33:36,160 --> 00:33:42,140
or receive a packet
from the upper part.

490
00:33:42,140 --> 00:33:44,090
So that will be a
really good idea.

491
00:33:44,090 --> 00:33:46,220
So let's define that.

492
00:33:46,220 --> 00:33:52,460
So we say that in our solution,
we will design it such

493
00:33:52,460 --> 00:33:57,020
that the path from
input i is actually

494
00:33:57,020 --> 00:34:08,139
going to be rightward
to column pi i

495
00:34:08,139 --> 00:34:19,250
and then downward to the
output-- so downward to output

496
00:34:19,250 --> 00:34:21,280
by i.

497
00:34:21,280 --> 00:34:28,870
So this is a really good
solution to the routing problem

498
00:34:28,870 --> 00:34:32,820
because now, we can continue
our proof as follows.

499
00:34:32,820 --> 00:34:43,440
We just say, well, if you
look at the switch in row i

500
00:34:43,440 --> 00:34:50,969
and column pi i, well,
this one actually

501
00:34:50,969 --> 00:35:03,260
transmits at most two packets
because a packet can only

502
00:35:03,260 --> 00:35:10,880
come from the left or it's
going to go from the top.

503
00:35:10,880 --> 00:35:15,810
So either one of the two--
at most, those two packets

504
00:35:15,810 --> 00:35:17,990
will go through the switch.

505
00:35:17,990 --> 00:35:24,050
So this shows that we have
a congestion of at most two

506
00:35:24,050 --> 00:35:25,990
for any permutation.

507
00:35:25,990 --> 00:35:28,360
And in order to prove
equality, because that's really

508
00:35:28,360 --> 00:35:30,060
what the theorem
says, we also have

509
00:35:30,060 --> 00:35:33,480
to show that there
exists a permutation that

510
00:35:33,480 --> 00:35:36,300
achieves a congestion of two.

511
00:35:36,300 --> 00:35:38,340
And that is pretty
straightforward.

512
00:35:38,340 --> 00:35:43,310
We can, for example use
a specific permutation

513
00:35:43,310 --> 00:35:51,980
that maps zero to zero and
maps n minus 1 to n minus 1.

514
00:35:51,980 --> 00:35:53,940
Well, for this
particular permutation,

515
00:35:53,940 --> 00:35:57,500
when we look at the
picture over here,

516
00:35:57,500 --> 00:36:03,630
we see that input zero
needs to go to output zero.

517
00:36:03,630 --> 00:36:09,370
We also see that this
lowest input, input three,

518
00:36:09,370 --> 00:36:12,370
needs to travel all
the way up to here.

519
00:36:12,370 --> 00:36:15,570
But it's clear that the packet
that needs to go over here

520
00:36:15,570 --> 00:36:23,140
needs to travel through that
switch in the lower left bottom

521
00:36:23,140 --> 00:36:24,360
corner.

522
00:36:24,360 --> 00:36:28,000
And the input three also
needs to travel through that.

523
00:36:28,000 --> 00:36:32,510
So here, we clearly see that we
you have a congestion of two.

524
00:36:32,510 --> 00:36:35,140
So now, the proof is
complete because we

525
00:36:35,140 --> 00:36:37,460
have shown this upper bound.

526
00:36:37,460 --> 00:36:41,170
So for any permutation, the
congestion is at most two

527
00:36:41,170 --> 00:36:48,170
and we see that this
specific permutation achieves

528
00:36:48,170 --> 00:36:49,840
this congestion.

529
00:36:49,840 --> 00:36:52,840
So this is the
end of this proof.

530
00:36:52,840 --> 00:36:54,070
So that's great.

531
00:36:54,070 --> 00:36:55,570
So now, what we'd
like to do is we'd

532
00:36:55,570 --> 00:36:58,660
like to combine
these two networks

533
00:36:58,660 --> 00:37:01,340
and see what we can
learn from both.

534
00:37:01,340 --> 00:37:09,910
So now, we'll be taking out
a lot of chalk over here.

535
00:37:09,910 --> 00:37:14,600
So the idea is to construct
a butterfly network

536
00:37:14,600 --> 00:37:19,930
and I will draw it in
such a way that you can

537
00:37:19,930 --> 00:37:21,200
see the recursive structure.

538
00:37:25,620 --> 00:37:34,630
The idea is to do
the following thing.

539
00:37:34,630 --> 00:37:39,532
So let me see how I
can do this the best.

540
00:37:39,532 --> 00:37:45,240
So I will just do the top line
first and I have the spacing.

541
00:37:45,240 --> 00:37:50,710
So we have input zero, a
terminal, we have a switch,

542
00:37:50,710 --> 00:37:58,230
we have a switch, we have
a switch, and another one,

543
00:37:58,230 --> 00:38:02,900
and here, we have
the output zero.

544
00:38:02,900 --> 00:38:06,860
So the whole idea
is that I'm going

545
00:38:06,860 --> 00:38:13,800
to combine every two outputs
by using a small butterfly

546
00:38:13,800 --> 00:38:15,820
structure.

547
00:38:15,820 --> 00:38:26,949
So we have two, output three,
output four-- actually,

548
00:38:26,949 --> 00:38:28,240
I need a little bit more space.

549
00:38:33,001 --> 00:38:46,460
Do it once more, output
one, two, three, four, five,

550
00:38:46,460 --> 00:38:49,340
six, and a last one, seven.

551
00:38:49,340 --> 00:38:51,900
This is going to be
pretty tight on the board.

552
00:38:51,900 --> 00:38:54,290
So what's happening is this.

553
00:38:54,290 --> 00:38:57,670
So these are all connected,
of course, to switches.

554
00:38:57,670 --> 00:38:59,050
The switches output those.

555
00:39:05,540 --> 00:39:11,490
And the idea is that we create
the following structure.

556
00:39:11,490 --> 00:39:14,340
This switch can either
forward it over here

557
00:39:14,340 --> 00:39:17,430
or it can cross it over
to this particular line.

558
00:39:17,430 --> 00:39:20,720
And this switch can either
forward it or cross it over

559
00:39:20,720 --> 00:39:21,410
to this line.

560
00:39:21,410 --> 00:39:24,180
So this is a very small
butterfly structure.

561
00:39:24,180 --> 00:39:27,980
Here, we have two
inputs and two outputs.

562
00:39:27,980 --> 00:39:31,340
And we will repeat this
process and we'll do the same

563
00:39:31,340 --> 00:39:33,420
on each of these other levels.

564
00:39:33,420 --> 00:39:44,160
So we forward those or
we cross them, like this.

565
00:39:48,460 --> 00:39:53,190
And now that we have constructed
all these smaller butterfly

566
00:39:53,190 --> 00:39:56,360
structures, we can start
to combine two butterfly

567
00:39:56,360 --> 00:39:59,020
structures together
in the bigger one.

568
00:39:59,020 --> 00:40:01,180
So here, we had two
outputs that we combined

569
00:40:01,180 --> 00:40:03,030
in a butterfly structure.

570
00:40:03,030 --> 00:40:04,700
Now, we use two
butterfly structures

571
00:40:04,700 --> 00:40:09,930
that we put into
a bigger version.

572
00:40:09,930 --> 00:40:11,580
So how do we do this?

573
00:40:11,580 --> 00:40:16,130
Well, we have that the
upper half over here

574
00:40:16,130 --> 00:40:21,300
can either forward those
packets or cross them over

575
00:40:21,300 --> 00:40:25,510
to the bottom part
butterfly structure.

576
00:40:25,510 --> 00:40:30,880
So for these, we can either
forward them straight on

577
00:40:30,880 --> 00:40:36,290
or we can go to
the top butterfly.

578
00:40:36,290 --> 00:40:40,650
So you see that these two
inputs, these two switches,

579
00:40:40,650 --> 00:40:46,330
either can forward packets
to this sub-butterfly network

580
00:40:46,330 --> 00:40:50,220
or to the top butterfly network.

581
00:40:50,220 --> 00:40:54,840
Now, we'll continue this
process and for these, you'll

582
00:40:54,840 --> 00:40:55,800
do the same.

583
00:40:55,800 --> 00:41:01,490
So we can either go
straight or we go down.

584
00:41:01,490 --> 00:41:03,520
And over here, we
can go straight

585
00:41:03,520 --> 00:41:08,320
or we can go to the
top butterfly network.

586
00:41:08,320 --> 00:41:15,520
Well, now we have the final part
where we combine essentially

587
00:41:15,520 --> 00:41:19,170
these two butterfly networks.

588
00:41:19,170 --> 00:41:23,110
We have two butterfly networks
created here now composed again

589
00:41:23,110 --> 00:41:24,710
of smaller ones
and these two are

590
00:41:24,710 --> 00:41:27,660
being composed to this
bigger butterfly network.

591
00:41:27,660 --> 00:41:32,410
Again, we take
these four switches.

592
00:41:32,410 --> 00:41:34,620
They can route their
packets forward

593
00:41:34,620 --> 00:41:40,250
to the top butterfly sub-network
or to the bottom one.

594
00:41:40,250 --> 00:41:43,650
So they can either
go straight ahead

595
00:41:43,650 --> 00:41:48,480
or this one can connect
to the first over here,

596
00:41:48,480 --> 00:41:53,410
this one to the second, to the
third, and this to the fourth.

597
00:41:53,410 --> 00:41:59,500
And in the same style, these can
forward them straight like this

598
00:41:59,500 --> 00:42:09,760
and then go up like this.

599
00:42:09,760 --> 00:42:12,210
And these are all connected
because in this example,

600
00:42:12,210 --> 00:42:15,300
let's just have an
eight by eight network,

601
00:42:15,300 --> 00:42:16,720
butterfly network.

602
00:42:16,720 --> 00:42:21,790
We have input zero to seven.

603
00:42:32,820 --> 00:42:34,304
So this is the
butterfly network.

604
00:42:34,304 --> 00:42:35,720
In a way, what you
can see here is

605
00:42:35,720 --> 00:42:38,950
you can see sort of the
two-dimensional structure,

606
00:42:38,950 --> 00:42:41,640
like we have rows and columns.

607
00:42:41,640 --> 00:42:46,330
At the same time, we can also
see this binary sort of tree

608
00:42:46,330 --> 00:42:51,860
feeling we get from it, which
is that a switch can forward

609
00:42:51,860 --> 00:42:58,040
sort of its packets to
either, say, the top butterfly

610
00:42:58,040 --> 00:42:59,420
or the bottom butterfly.

611
00:42:59,420 --> 00:43:01,900
So there's a split in two.

612
00:43:01,900 --> 00:43:03,270
The same for this one, right?

613
00:43:03,270 --> 00:43:07,020
This one goes either to
this butterfly network

614
00:43:07,020 --> 00:43:09,850
or it goes to this
butterfly network.

615
00:43:09,850 --> 00:43:12,200
So you have this tree
structure sort of

616
00:43:12,200 --> 00:43:16,000
embedded in this
two-dimensional structure.

617
00:43:16,000 --> 00:43:18,580
So what are the
properties of this one?

618
00:43:18,580 --> 00:43:28,690
So let me first define in
more formal mathematics

619
00:43:28,690 --> 00:43:31,660
how the switches
route their packets,

620
00:43:31,660 --> 00:43:35,630
so how the connections are.

621
00:43:35,630 --> 00:43:39,420
So in order to do that, we are
going to label each switch.

622
00:43:42,720 --> 00:43:46,880
And the idea is that we're
going to label it by its row

623
00:43:46,880 --> 00:43:48,480
and by its column.

624
00:43:48,480 --> 00:43:53,580
So we will have--
the columns are

625
00:43:53,580 --> 00:44:01,530
numbered by level zero, level
one, level two, level three,

626
00:44:01,530 --> 00:44:02,580
yes?

627
00:44:02,580 --> 00:44:06,625
And the rows are
these integers, but we

628
00:44:06,625 --> 00:44:09,930
are going to represent
them by binary numbers.

629
00:44:09,930 --> 00:44:22,210
So zero would be 000, 001,
010, 011-- oops-- 100, 101,

630
00:44:22,210 --> 00:44:29,320
and then we got 110 and 111.

631
00:44:29,320 --> 00:44:32,850
So for example, this particular
switch would be labeled

632
00:44:32,850 --> 00:44:38,040
by these three bits, 001,
and the integer number, 1.

633
00:44:38,040 --> 00:44:48,520
This one would be 011 and its
column is indexed by integer 2.

634
00:44:48,520 --> 00:45:04,010
So a switch is
uniquely identified

635
00:45:04,010 --> 00:45:09,130
by its row and column.

636
00:45:12,340 --> 00:45:18,820
We will have b1
up to b logarithm

637
00:45:18,820 --> 00:45:22,060
of n, which are
the number of bits

638
00:45:22,060 --> 00:45:25,670
to represent the row in
digits, and to finally

639
00:45:25,670 --> 00:45:31,300
have an integer l and this
we will call the level.

640
00:45:31,300 --> 00:45:37,480
So this particular switch either
directs or routes a packet

641
00:45:37,480 --> 00:45:43,790
to the switch that is
indexed by b one up to--

642
00:45:43,790 --> 00:45:48,590
and then we get b, l plus 1
and we take its complement.

643
00:45:48,590 --> 00:45:51,570
So instead of if b,
l plus n would be 1,

644
00:45:51,570 --> 00:45:53,280
we would have a 0 here.

645
00:45:53,280 --> 00:45:55,780
If it would be a 0, we
will have a 1 over here.

646
00:45:58,370 --> 00:46:05,030
But we repeat all the other
bits and we get to b log n.

647
00:46:05,030 --> 00:46:07,840
And it routes us back
to the next level.

648
00:46:07,840 --> 00:46:11,480
So we will have l plus 1.

649
00:46:11,480 --> 00:46:15,480
Another possibility because
there are two outgoing edges

650
00:46:15,480 --> 00:46:23,570
is if we have just b1 and
we just copy b, l plus 1,

651
00:46:23,570 --> 00:46:24,830
essentially.

652
00:46:24,830 --> 00:46:26,890
We route a packet
straightforward.

653
00:46:26,890 --> 00:46:29,330
We don't do anything special.

654
00:46:29,330 --> 00:46:33,300
We get b log n over here
and then to the next level.

655
00:46:33,300 --> 00:46:37,980
So for example, let's see where
we can see how this works.

656
00:46:37,980 --> 00:46:42,210
So for example, take
this particular switch.

657
00:46:42,210 --> 00:46:45,980
We have 010.

658
00:46:45,980 --> 00:46:48,670
So it can either go straight
on to the next level.

659
00:46:48,670 --> 00:46:52,300
It would go to 010 but
then instead of level one,

660
00:46:52,300 --> 00:46:58,070
we have level two, which is
the right edge over there.

661
00:46:58,070 --> 00:47:02,810
The other one is if
this one goes up, well,

662
00:47:02,810 --> 00:47:14,120
we will need to switch the
first bit over here, a 1.

663
00:47:14,120 --> 00:47:19,010
We swap it into 0 and then we
go to the three zeros over here

664
00:47:19,010 --> 00:47:21,120
and we go to the
next level and that

665
00:47:21,120 --> 00:47:24,350
would be this particular rule.

666
00:47:24,350 --> 00:47:29,650
So what we can do here is
to-- so when we see this,

667
00:47:29,650 --> 00:47:34,220
we can start to figure out
how we can direct inputs

668
00:47:34,220 --> 00:47:36,040
to outputs.

669
00:47:36,040 --> 00:47:38,390
So let's do this.

670
00:47:45,410 --> 00:47:55,950
So suppose I want to route a
packet from a certain input,

671
00:47:55,950 --> 00:48:04,430
one of these, all the way to
one of the outputs over here.

672
00:48:04,430 --> 00:48:09,900
So the way to do
this is as follows.

673
00:48:09,900 --> 00:48:15,610
We can just start-- for example,
I want to go from switch x1

674
00:48:15,610 --> 00:48:21,120
up to x log n comma 0.

675
00:48:21,120 --> 00:48:24,830
So I start completely
at the left over here

676
00:48:24,830 --> 00:48:28,780
and I want to go somewhere
of my choice to the right.

677
00:48:28,780 --> 00:48:36,660
So I want to somehow move all
the way to some other row, y1

678
00:48:36,660 --> 00:48:41,660
indexed by y by the bit
pattern, y1 up to y log n,

679
00:48:41,660 --> 00:48:46,670
but now at the very last
level, which is log n.

680
00:48:46,670 --> 00:48:48,980
Well, how do I do it?

681
00:48:48,980 --> 00:48:51,550
Well, this switch, I can
use that rule up there

682
00:48:51,550 --> 00:48:55,380
and simply change x1 to y1.

683
00:48:55,380 --> 00:48:59,600
I can either leave x1 as it
is if it's the same as y1

684
00:48:59,600 --> 00:49:01,840
or I can swap it
to its complement

685
00:49:01,840 --> 00:49:04,570
if that's the value of y1.

686
00:49:04,570 --> 00:49:10,540
So what I can do is I can
just simply route it to y1.

687
00:49:10,540 --> 00:49:13,950
And then, I leave all
the other bits the same,

688
00:49:13,950 --> 00:49:19,940
which are x2, x3, all
the way up to x log n.

689
00:49:19,940 --> 00:49:27,310
And we will have
reached the first level.

690
00:49:27,310 --> 00:49:30,930
Now, this one can go
to-- well, now I'm

691
00:49:30,930 --> 00:49:34,420
going to swap the second bit
into the bit of my choice.

692
00:49:34,420 --> 00:49:37,560
So I leave all the other
bits the same, y1 the same,

693
00:49:37,560 --> 00:49:39,470
x3, all the others the same.

694
00:49:39,470 --> 00:49:43,900
I just swap x2 into y2.

695
00:49:43,900 --> 00:49:50,100
So we leave all those equal
and we go to the second level.

696
00:49:50,100 --> 00:49:54,880
And then, we go all the
way to the final level

697
00:49:54,880 --> 00:49:56,934
and we one by one
swap all these bits.

698
00:49:56,934 --> 00:49:57,975
So let's have an example.

699
00:50:00,950 --> 00:50:04,030
Suppose I want to
connect, let's say,

700
00:50:04,030 --> 00:50:10,960
this one to for
example, well, let's say

701
00:50:10,960 --> 00:50:13,120
this particular output.

702
00:50:13,120 --> 00:50:19,570
So what's the
binary for this one?

703
00:50:19,570 --> 00:50:22,900
This is actually 101.

704
00:50:22,900 --> 00:50:29,030
So if the first bit is
different, I need to cross.

705
00:50:29,030 --> 00:50:32,760
And otherwise, I need
to pass straight on.

706
00:50:32,760 --> 00:50:35,260
So let's do this.

707
00:50:35,260 --> 00:50:37,530
So over here, I'm in 011.

708
00:50:37,530 --> 00:50:42,110
I need to go to 101 so we need
to change the zero into a one.

709
00:50:42,110 --> 00:50:45,444
So I need to go down.

710
00:50:45,444 --> 00:50:46,110
I need to cross.

711
00:50:51,150 --> 00:50:55,790
Now, if I look at
the second bit,

712
00:50:55,790 --> 00:51:00,190
I also need to change
it to a zero so again,

713
00:51:00,190 --> 00:51:05,020
I need to cross,
which is over here.

714
00:51:05,020 --> 00:51:10,240
Now, the third bit is equal
to 1 and it's the same.

715
00:51:10,240 --> 00:51:11,750
So now, I can go straight ahead.

716
00:51:11,750 --> 00:51:18,280
I do not cross and I
end up at this output.

717
00:51:18,280 --> 00:51:19,380
So what did I do?

718
00:51:19,380 --> 00:51:22,310
For every bit that
is different, I cross

719
00:51:22,310 --> 00:51:25,480
and for the bits that are the
same, I go straight ahead.

720
00:51:25,480 --> 00:51:28,796
So this is how I can route
packets from one input

721
00:51:28,796 --> 00:51:29,546
to another output.

722
00:51:34,860 --> 00:51:38,340
So let's look at the parameters.

723
00:51:38,340 --> 00:51:43,810
First of all, if you
look at the diameter,

724
00:51:43,810 --> 00:51:46,480
well, it turns out that
that's approximately

725
00:51:46,480 --> 00:51:51,800
equal to the number of levels,
which is the logarithm of n.

726
00:51:51,800 --> 00:51:55,210
And to be precise, it's
actually equal to 2

727
00:51:55,210 --> 00:51:57,600
plus the logarithm of n.

728
00:51:57,600 --> 00:51:59,734
So that's great.

729
00:51:59,734 --> 00:52:00,650
That's a good scaling.

730
00:52:00,650 --> 00:52:02,480
Again, it's back to
the logarithm of n.

731
00:52:02,480 --> 00:52:06,410
So we have the best of
these two parameters.

732
00:52:06,410 --> 00:52:10,790
The switches that we see have
two inputs and two outputs.

733
00:52:10,790 --> 00:52:15,710
So we again have a
two times two switch.

734
00:52:15,710 --> 00:52:18,380
The number of
switches is the number

735
00:52:18,380 --> 00:52:20,170
of rows times the
number of columns.

736
00:52:20,170 --> 00:52:22,790
The number of columns is the
logarithm of n and number

737
00:52:22,790 --> 00:52:26,369
of rows is equal to n.

738
00:52:26,369 --> 00:52:27,910
And to make it a
little bit, precise,

739
00:52:27,910 --> 00:52:31,050
it's 1 plus the logarithm of n.

740
00:52:31,050 --> 00:52:32,910
So that's somewhere
in between those two.

741
00:52:32,910 --> 00:52:34,520
But if you're thinking
about it, it's

742
00:52:34,520 --> 00:52:35,950
much better than n squared.

743
00:52:35,950 --> 00:52:40,510
It's almost linear except
for a logarithmic factor.

744
00:52:40,510 --> 00:52:42,410
For the congestion--
and we are not

745
00:52:42,410 --> 00:52:46,200
going to talk about it here,
but you have a problem set

746
00:52:46,200 --> 00:52:49,720
assignment that will
ask you to solve

747
00:52:49,720 --> 00:52:54,160
this-- is that
actually, the congestion

748
00:52:54,160 --> 00:52:59,650
is the square root of n or it's
equal to the square root of n

749
00:52:59,650 --> 00:53:04,300
over 2, depending on
whether n is an even power

750
00:53:04,300 --> 00:53:06,355
or n is an odd power.

751
00:53:06,355 --> 00:53:07,980
Now, we're not going
to prove that here

752
00:53:07,980 --> 00:53:10,860
because we want to step forward
to this particular network.

753
00:53:10,860 --> 00:53:12,620
It's very exciting.

754
00:53:12,620 --> 00:53:16,100
And you will prove this
in your problem set.

755
00:53:16,100 --> 00:53:18,750
So this one is somewhere
in between, somewhere

756
00:53:18,750 --> 00:53:20,810
in between these two extremes.

757
00:53:20,810 --> 00:53:25,100
Now, it will be really
fantastic if we can somehow

758
00:53:25,100 --> 00:53:28,580
transform this network
with a trick to,

759
00:53:28,580 --> 00:53:31,310
again, have a really
great congestion

760
00:53:31,310 --> 00:53:36,550
of just a constant, like two
or three or whatever or maybe

761
00:53:36,550 --> 00:53:37,910
even one.

762
00:53:37,910 --> 00:53:42,780
So for this particular
network, in the 1960s,

763
00:53:42,780 --> 00:53:46,320
Benes, a Bell Labs
researcher, had the great idea

764
00:53:46,320 --> 00:53:51,490
to use a butterfly network
and attach to it, again,

765
00:53:51,490 --> 00:53:55,680
a butterfly network,
back to back sort of.

766
00:53:55,680 --> 00:53:58,160
So what was his idea?

767
00:53:58,160 --> 00:54:02,910
His idea was to
do the following.

768
00:54:02,910 --> 00:54:10,500
So the butterfly network
as we have it right now

769
00:54:10,500 --> 00:54:14,080
is this particular
part over here.

770
00:54:14,080 --> 00:54:20,300
And the idea is now to start
up mixing all those outputs

771
00:54:20,300 --> 00:54:24,550
that we got here together
again using a similar rule.

772
00:54:24,550 --> 00:54:25,990
So what do we do?

773
00:54:25,990 --> 00:54:36,270
We are going to
essentially repeat

774
00:54:36,270 --> 00:54:41,030
this particular
structure on this side.

775
00:54:41,030 --> 00:54:43,090
So how do we do it?

776
00:54:43,090 --> 00:54:48,850
Well, we go either
straightforward

777
00:54:48,850 --> 00:54:51,070
or we start to mix them again.

778
00:54:51,070 --> 00:54:55,150
So it's like this output,
this particular switch,

779
00:54:55,150 --> 00:54:57,960
can either go straight
ahead or can cross

780
00:54:57,960 --> 00:55:01,940
to the lower part over here.

781
00:55:01,940 --> 00:55:03,860
It goes over here and
this one goes over.

782
00:55:03,860 --> 00:55:08,240
So as you can see, we
have repeated this part.

783
00:55:08,240 --> 00:55:12,040
It's exactly the same as
this structure over here.

784
00:55:12,040 --> 00:55:19,820
We'll do the same for this part.

785
00:55:19,820 --> 00:55:24,910
So we can either cross or
we can go straight ahead.

786
00:55:24,910 --> 00:55:27,390
Oh, we also have, of
course, that these switches

787
00:55:27,390 --> 00:55:31,470
can go straight ahead
or can cross to the top.

788
00:55:31,470 --> 00:55:33,400
I forgot about that.

789
00:55:33,400 --> 00:55:37,080
So we have this--
oops-- as well.

790
00:55:37,080 --> 00:55:39,320
So as you can see, this
particular structure

791
00:55:39,320 --> 00:55:41,960
repeats itself
again and we slowly

792
00:55:41,960 --> 00:55:45,820
start to build up in mixing
all the outputs again

793
00:55:45,820 --> 00:55:54,510
or the possibility, at least,
to route them to any other row.

794
00:55:54,510 --> 00:55:55,810
So how do we do this?

795
00:55:55,810 --> 00:55:57,920
Well, we continue this
particular structure now

796
00:55:57,920 --> 00:55:58,500
over here.

797
00:55:58,500 --> 00:56:01,850
So all these can either
go straight ahead.

798
00:56:07,435 --> 00:56:08,310
That's a possibility.

799
00:56:11,570 --> 00:56:15,330
Or they can go all down.

800
00:56:18,690 --> 00:56:20,850
So this switch can
either go straight ahead

801
00:56:20,850 --> 00:56:24,790
or can go to the lower half.

802
00:56:24,790 --> 00:56:26,610
And for these, we have
a similar structure.

803
00:56:26,610 --> 00:56:33,340
We can either go straight ahead
or such a switch can cross over

804
00:56:33,340 --> 00:56:36,630
to the top over here.

805
00:56:42,180 --> 00:56:43,480
So that's this.

806
00:56:43,480 --> 00:56:46,300
So this is Benes network and
then over here, of course,

807
00:56:46,300 --> 00:56:59,970
we have the outputs, zero, one,
and all the way down to seven.

808
00:57:11,340 --> 00:57:15,060
So as you can see over
here, the structure again

809
00:57:15,060 --> 00:57:17,980
has a recursive nature to it.

810
00:57:17,980 --> 00:57:24,340
You can see that this big
Benes network over here

811
00:57:24,340 --> 00:57:27,350
consists of two
smaller ones that

812
00:57:27,350 --> 00:57:30,390
are right here in the
middle, this one that

813
00:57:30,390 --> 00:57:33,560
goes all the way up to
here-- so maybe I should

814
00:57:33,560 --> 00:57:37,290
put a color boundary around it.

815
00:57:37,290 --> 00:57:44,280
Let me check I want
to do this-- right.

816
00:57:44,280 --> 00:57:52,150
So this particular
part, is again

817
00:57:52,150 --> 00:57:58,810
a Benes network and the top
part in the same picture,

818
00:57:58,810 --> 00:58:05,800
the top subnetwork is also
a Benes network, this part.

819
00:58:13,300 --> 00:58:15,880
And if you look
within those, we again

820
00:58:15,880 --> 00:58:20,600
see a top part
and a bottom part.

821
00:58:20,600 --> 00:58:25,830
And over here, we see a top
part and also a bottom part.

822
00:58:25,830 --> 00:58:31,500
So you see this recursive
nature again reappearing.

823
00:58:31,500 --> 00:58:33,930
It turns out that
with this trick,

824
00:58:33,930 --> 00:58:36,620
we can completely
eliminate congestion

825
00:58:36,620 --> 00:58:40,600
and we can get it to only one,
which is really surprising.

826
00:58:40,600 --> 00:58:42,800
And that what we're
going to prove here.

827
00:58:42,800 --> 00:58:45,690
So this is a great
invention at the time.

828
00:58:45,690 --> 00:58:48,870
It's really, really beautiful.

829
00:58:48,870 --> 00:58:51,880
So let me put in the
other parameters.

830
00:58:51,880 --> 00:58:54,080
So they stay
approximately the same

831
00:58:54,080 --> 00:58:57,240
up to that the diameter
is about twice as

832
00:58:57,240 --> 00:59:00,850
large because we added another
sort of whole butterfly

833
00:59:00,850 --> 00:59:02,520
structure to it.

834
00:59:02,520 --> 00:59:05,960
The switch size stays the same.

835
00:59:05,960 --> 00:59:11,190
We, again, have about
two times more switches

836
00:59:11,190 --> 00:59:16,080
so they sort of stay about the
same up to a linear factor,

837
00:59:16,080 --> 00:59:18,380
like a constant factor.

838
00:59:18,380 --> 00:59:22,210
And the congestion, however,
completely dropped down to one.

839
00:59:22,210 --> 00:59:24,490
So that's what we're
going to prove now.

840
00:59:24,490 --> 00:59:27,401
And in order to
get some intuition,

841
00:59:27,401 --> 00:59:29,150
well, let me first
write down the theorem.

842
00:59:32,330 --> 00:59:36,850
Actually, let me
put this over here.

843
00:59:43,840 --> 00:59:54,530
So in order to get
some insight into this,

844
00:59:54,530 --> 00:59:56,410
we are going to use
this recursive nature.

845
00:59:56,410 --> 00:59:58,118
So we're going to use
induction and we're

846
00:59:58,118 --> 01:00:03,100
going to say, oh,
for any permutation,

847
01:00:03,100 --> 01:00:07,910
I can find really good routing
for say, this red subnetwork

848
01:00:07,910 --> 01:00:09,870
and for this blue subnetwork.

849
01:00:09,870 --> 01:00:11,580
So I know that.

850
01:00:11,580 --> 01:00:17,960
So what I need to do is, if I
have my bigger Benes network,

851
01:00:17,960 --> 01:00:21,450
like this one, I would
need to somehow map

852
01:00:21,450 --> 01:00:25,330
these inputs-- I
need to route them

853
01:00:25,330 --> 01:00:29,360
to either the top and the bottom
subnetwork, one of the two,

854
01:00:29,360 --> 01:00:32,840
in such a way that
there will be absolutely

855
01:00:32,840 --> 01:00:35,080
no congestion, because
we want to keep this one.

856
01:00:35,080 --> 01:00:39,300
So a switch should only
see one packet coming in.

857
01:00:39,300 --> 01:00:42,460
So that means, for example--
and we'll come back to that--

858
01:00:42,460 --> 01:00:44,090
that for example,
for this switch,

859
01:00:44,090 --> 01:00:47,260
it should not receive a
packet from both this input

860
01:00:47,260 --> 01:00:49,080
and from this input.

861
01:00:49,080 --> 01:00:51,530
So the intuition that
we are going to create

862
01:00:51,530 --> 01:00:58,510
is we're going to list our
constraints, the constraints

863
01:00:58,510 --> 01:01:02,930
that we need to satisfy, like
the zero and the fourth input

864
01:01:02,930 --> 01:01:07,950
should not both be mapped to
this top subnetwork and so on.

865
01:01:07,950 --> 01:01:10,090
So we will get into
that and then we

866
01:01:10,090 --> 01:01:15,100
will gain a lot of intuition
on how to solve this.

867
01:01:15,100 --> 01:01:17,970
So what's the theorem?

868
01:01:17,970 --> 01:01:32,970
So the theorem is that the
congestion of the n-input Benes

869
01:01:32,970 --> 01:01:41,110
network is actually equal to 1.

870
01:01:41,110 --> 01:01:46,320
And we will prove this for
n equal to a power of 2.

871
01:01:46,320 --> 01:01:50,260
We have assumed
that at the start

872
01:01:50,260 --> 01:01:54,280
that we had with all the
other networks, as well.

873
01:01:54,280 --> 01:02:00,340
And in this case, we
will use induction on a.

874
01:02:00,340 --> 01:02:04,280
So that's the
method that we will

875
01:02:04,280 --> 01:02:06,790
do because that's also
the recursive structure

876
01:02:06,790 --> 01:02:09,150
of the Benes network itself.

877
01:02:09,150 --> 01:02:17,930
So we will use
induction on a and we

878
01:02:17,930 --> 01:02:21,150
are going to define the
induction hypothesis simply

879
01:02:21,150 --> 01:02:34,210
as, "The theorem is true for a."

880
01:02:34,210 --> 01:02:35,570
Now, let us do the base case.

881
01:02:35,570 --> 01:02:37,840
We always start
with the base case

882
01:02:37,840 --> 01:02:41,140
and that should be pretty
easy because this is

883
01:02:41,140 --> 01:02:44,240
the most basic Benes network.

884
01:02:44,240 --> 01:02:48,630
So n equals 2 to the power of 1.

885
01:02:48,630 --> 01:02:57,210
We essentially have two inputs,
an input zero and an input one.

886
01:02:57,210 --> 01:02:59,810
They are connected to these
switches over here that

887
01:02:59,810 --> 01:03:05,010
can either forward them
or can cross them over

888
01:03:05,010 --> 01:03:08,850
and then they go
directly to the output.

889
01:03:08,850 --> 01:03:10,250
Notice that in
this case, we just

890
01:03:10,250 --> 01:03:12,800
have the most elementary
butterfly network.

891
01:03:12,800 --> 01:03:14,780
It's the same.

892
01:03:14,780 --> 01:03:19,160
So we have output
zero and output one.

893
01:03:19,160 --> 01:03:21,270
So this corresponds
in this picture

894
01:03:21,270 --> 01:03:25,090
to these little small
things over here,

895
01:03:25,090 --> 01:03:28,620
this one and this one
and this one over here

896
01:03:28,620 --> 01:03:32,440
and the fourth one over here.

897
01:03:32,440 --> 01:03:34,630
So now, let's take
any permutation.

898
01:03:34,630 --> 01:03:37,300
We want to show that we
can route it in such a way

899
01:03:37,300 --> 01:03:40,910
that there's only a
congestion of one.

900
01:03:40,910 --> 01:03:41,890
So let's do this.

901
01:03:51,970 --> 01:03:54,620
So there are essentially
only two permutations.

902
01:03:54,620 --> 01:03:56,960
Either zero is mapped
to zero and one

903
01:03:56,960 --> 01:03:59,650
is mapped to one or
zero is mapped to one

904
01:03:59,650 --> 01:04:01,090
and one is mapped to zero.

905
01:04:04,280 --> 01:04:07,690
So in both cases, we
can just route them

906
01:04:07,690 --> 01:04:11,890
through their own switches.

907
01:04:11,890 --> 01:04:17,870
So we have that either pi
of 0 equals 0 and pi of 1

908
01:04:17,870 --> 01:04:23,460
equals 1, in which case we just
direct them straight through

909
01:04:23,460 --> 01:04:26,410
and we go straight through
and every switch only

910
01:04:26,410 --> 01:04:27,930
sees a packet once.

911
01:04:27,930 --> 01:04:30,310
So for this particular
permutation,

912
01:04:30,310 --> 01:04:32,810
we have a congestion of one.

913
01:04:32,810 --> 01:04:36,160
Now, the other permutation
that we can have

914
01:04:36,160 --> 01:04:40,660
is if zero is mapped to one
and if one is mapped to zero.

915
01:04:40,660 --> 01:04:44,110
Well, in that
case, we just route

916
01:04:44,110 --> 01:04:48,400
this cross over
to the bottom row

917
01:04:48,400 --> 01:04:51,650
and here we go from this
switch to the top row.

918
01:04:51,650 --> 01:04:55,490
Again, every switch
only sees a packet once.

919
01:04:55,490 --> 01:04:58,460
So in this case, in the
base case, we are done.

920
01:04:58,460 --> 01:04:59,330
We are happy.

921
01:04:59,330 --> 01:05:02,871
We have shown that the
congestion is equal to one.

922
01:05:02,871 --> 01:05:07,060
So now, it gets
to the harder part

923
01:05:07,060 --> 01:05:10,640
because for the
inductive step, we

924
01:05:10,640 --> 01:05:15,560
are going to assume,
of course, that it

925
01:05:15,560 --> 01:05:19,200
holds true for a
smaller Benes network.

926
01:05:19,200 --> 01:05:29,330
So we assume that P a
is true and well, let's

927
01:05:29,330 --> 01:05:32,980
try to gain some insight here.

928
01:05:32,980 --> 01:05:37,600
So we know from our
induction hypothesis,

929
01:05:37,600 --> 01:05:43,830
within each subnetwork, we
can solve any routing problem

930
01:05:43,830 --> 01:05:47,650
with congestion one and for
this subnetwork, the same.

931
01:05:47,650 --> 01:05:49,990
That's our induction hypothesis.

932
01:05:49,990 --> 01:05:51,390
So how do we go ahead?

933
01:05:51,390 --> 01:05:55,780
We need to somehow
map these inputs

934
01:05:55,780 --> 01:05:58,590
according to the
permutation of our choice.

935
01:05:58,590 --> 01:06:01,110
So that could be for
some input zero goes

936
01:06:01,110 --> 01:06:06,580
to output five or input one
goes to output two, et cetera.

937
01:06:06,580 --> 01:06:09,420
So somehow, we need
to choose where

938
01:06:09,420 --> 01:06:14,120
we are going to map this
particular input to.

939
01:06:14,120 --> 01:06:18,530
So packet zero that
comes from this input

940
01:06:18,530 --> 01:06:21,110
should either go
to the red network

941
01:06:21,110 --> 01:06:24,100
or it should go to
the blue network.

942
01:06:24,100 --> 01:06:27,999
And for each of these inputs,
we can make such a choice.

943
01:06:27,999 --> 01:06:29,540
But we have to be
very smart about it

944
01:06:29,540 --> 01:06:33,040
because we need to
avoid any congestion.

945
01:06:33,040 --> 01:06:34,970
So the intuition
is that we're going

946
01:06:34,970 --> 01:06:44,170
to set up a constraint graph,
a graph that represents all

947
01:06:44,170 --> 01:06:47,060
the constraints that we
need to satisfy in order

948
01:06:47,060 --> 01:06:49,990
to achieve congestion of one.

949
01:06:49,990 --> 01:06:52,720
So let's do an
example so that we

950
01:06:52,720 --> 01:06:54,910
can figure out what's going on.

951
01:06:54,910 --> 01:06:56,830
Actually, let me
put it over here.

952
01:06:59,540 --> 01:07:01,970
So just take an
example permutation

953
01:07:01,970 --> 01:07:03,970
and we'll go
through this example

954
01:07:03,970 --> 01:07:06,280
and then see how
the proof works.

955
01:07:09,240 --> 01:07:12,880
So let's as an example
have pi of zero maps

956
01:07:12,880 --> 01:07:22,710
to one, pi of one maps to
five, pi of two goes to four,

957
01:07:22,710 --> 01:07:30,826
input three goes to
seven, four maps to three,

958
01:07:30,826 --> 01:07:37,492
five to six, six to
zero, and seven to two.

959
01:07:37,492 --> 01:07:39,200
So this is just an
arbitrary permutation.

960
01:07:44,430 --> 01:07:46,060
So what do we see?

961
01:07:46,060 --> 01:07:50,820
We want to make sure that, for
example, this switch is only

962
01:07:50,820 --> 01:07:52,460
seeing one packet.

963
01:07:52,460 --> 01:07:57,490
So it cannot see a packet both
coming from input zero as well

964
01:07:57,490 --> 01:07:59,220
as from input four.

965
01:07:59,220 --> 01:08:00,670
I cannot see that.

966
01:08:00,670 --> 01:08:02,540
I do not want that to happen.

967
01:08:02,540 --> 01:08:04,260
Similarly, for
this one, I do not

968
01:08:04,260 --> 01:08:09,550
want to see a packet coming
from one or one from five.

969
01:08:09,550 --> 01:08:12,780
So let me define a constraint
graph that sort of represents

970
01:08:12,780 --> 01:08:14,500
this.

971
01:08:14,500 --> 01:08:22,029
So the constraint graph
that we are interested in

972
01:08:22,029 --> 01:08:23,080
is defined as follows.

973
01:08:27,479 --> 01:08:44,359
If two packets must pass
through different networks,

974
01:08:44,359 --> 01:08:56,569
subnetworks-- so in our case,
the red and blue subnetwork--

975
01:08:56,569 --> 01:09:00,600
then we'll actually have
an edge between those two.

976
01:09:00,600 --> 01:09:10,470
So then, there is an
edge between them.

977
01:09:10,470 --> 01:09:12,950
So for this example, we're
going to set up this constraint

978
01:09:12,950 --> 01:09:13,450
graph.

979
01:09:33,600 --> 01:09:37,029
So I was just talking about
this particular switch.

980
01:09:37,029 --> 01:09:41,020
It cannot see one coming from
four and a packet from zero.

981
01:09:41,020 --> 01:09:47,140
So what he have, we have an
edge between zero and four.

982
01:09:47,140 --> 01:09:52,539
In the same way, we have
an edge from one to five.

983
01:09:52,539 --> 01:09:53,390
Why?

984
01:09:53,390 --> 01:09:57,735
Because a packet that comes
from input one and a packet that

985
01:09:57,735 --> 01:10:02,150
comes from input five cannot
both be routed through

986
01:10:02,150 --> 01:10:05,370
the switch because then the
switch would see two packets

987
01:10:05,370 --> 01:10:08,220
and then the congestion would
not be one, but two, right?

988
01:10:08,220 --> 01:10:11,735
So one and five also
have an edge in between.

989
01:10:15,220 --> 01:10:20,760
And in the same way, we have
two and six and seven and three.

990
01:10:20,760 --> 01:10:28,520
So two and six is this
constraint, like two and six

991
01:10:28,520 --> 01:10:29,680
over here.

992
01:10:29,680 --> 01:10:32,250
And three and seven is
the other constraint.

993
01:10:32,250 --> 01:10:36,470
So if I have those constraints
in place, well then,

994
01:10:36,470 --> 01:10:41,540
I know that the routing
that goes from level zero

995
01:10:41,540 --> 01:10:46,580
to level one will not
violate my congestion of one.

996
01:10:46,580 --> 01:10:47,910
So that's great.

997
01:10:47,910 --> 01:10:51,110
Then, I hope to be able to
use the induction hypothesis

998
01:10:51,110 --> 01:10:54,160
and I get a proper routing
within the red subnetwork

999
01:10:54,160 --> 01:10:57,110
and one within the blue network.

1000
01:10:57,110 --> 01:11:00,770
And then, I need to map
all these to these outputs.

1001
01:11:00,770 --> 01:11:03,210
So I also have constraints
on these outputs

1002
01:11:03,210 --> 01:11:09,490
because, well, For example,
take this particular switch.

1003
01:11:09,490 --> 01:11:13,460
It should not see a packet
coming from this particular one

1004
01:11:13,460 --> 01:11:15,220
and one from this one.

1005
01:11:15,220 --> 01:11:16,460
So how do I code that up?

1006
01:11:23,950 --> 01:11:27,070
So let me first write
out what we did here

1007
01:11:27,070 --> 01:11:32,090
and then we'll do the same
for the last level over there.

1008
01:11:32,090 --> 01:11:34,840
So-- oh no, that's
not really necessary.

1009
01:11:41,770 --> 01:11:43,720
So at the output
side over here, we

1010
01:11:43,720 --> 01:11:46,710
have similar constraints
as we did over here.

1011
01:11:46,710 --> 01:11:51,800
And in this particular
example, just as an example,

1012
01:11:51,800 --> 01:11:55,630
suppose we look
at the packet that

1013
01:11:55,630 --> 01:12:04,827
is destined for output zero.

1014
01:12:04,827 --> 01:12:05,910
Well, what is this packet?

1015
01:12:05,910 --> 01:12:10,620
Well, I know that's
pi of 6 is equal to 0,

1016
01:12:10,620 --> 01:12:12,320
according to my example.

1017
01:12:12,320 --> 01:12:16,530
So packet six is destined
for this particular output

1018
01:12:16,530 --> 01:12:23,540
zero over here and goes
through this particular switch.

1019
01:12:23,540 --> 01:12:39,890
So this packet and
also the packet

1020
01:12:39,890 --> 01:12:46,820
for output four, which is if
you look at the mapping, pi of 2

1021
01:12:46,820 --> 01:12:48,420
is equal to 4.

1022
01:12:48,420 --> 01:12:51,360
So that's packet number two.

1023
01:12:51,360 --> 01:12:55,680
Well, both of these packets
cannot pass through the same

1024
01:12:55,680 --> 01:12:56,180
subnetwork.

1025
01:13:06,990 --> 01:13:08,320
So why is this?

1026
01:13:08,320 --> 01:13:11,020
So let's look at this
particular example.

1027
01:13:11,020 --> 01:13:18,680
So output zero, well,
comes from packet six,

1028
01:13:18,680 --> 01:13:20,315
somewhere over there.

1029
01:13:20,315 --> 01:13:25,780
Now suppose packet six was
routed through the red network

1030
01:13:25,780 --> 01:13:29,907
and at the same moment
also, output four--

1031
01:13:29,907 --> 01:13:31,990
the packet that is destined
for output four, which

1032
01:13:31,990 --> 01:13:36,890
is packet number two--
suppose packet two was also

1033
01:13:36,890 --> 01:13:40,010
going through the red network.

1034
01:13:40,010 --> 01:13:46,720
Well, then I notice that
both of these packets

1035
01:13:46,720 --> 01:13:51,260
must arrive at this particular
switch in order for one

1036
01:13:51,260 --> 01:13:54,640
to be routed to output
zero and the other one

1037
01:13:54,640 --> 01:13:57,890
to be routed to output four.

1038
01:13:57,890 --> 01:14:01,470
So in order to avoid congestion
in this particular switch

1039
01:14:01,470 --> 01:14:04,890
over here, we need
to have a constraint.

1040
01:14:04,890 --> 01:14:11,150
The constraint says that the
packet for packets two and six,

1041
01:14:11,150 --> 01:14:14,840
that those two cannot go
through the same subnetwork.

1042
01:14:14,840 --> 01:14:18,200
So essentially have
another edge over here--

1043
01:14:18,200 --> 01:14:23,640
we already had the constraint
but it's just the same edge.

1044
01:14:23,640 --> 01:14:27,940
So let's look at the other
constraints that we have.

1045
01:14:33,770 --> 01:14:35,960
Well, let's look at
a different example.

1046
01:14:35,960 --> 01:14:41,110
So for example, if I
look at this switch,

1047
01:14:41,110 --> 01:14:46,110
well, if a packet
goes through here

1048
01:14:46,110 --> 01:14:49,110
that needs to end up
at one and a packet

1049
01:14:49,110 --> 01:14:54,500
that's goes to five, if
those two packets are routed

1050
01:14:54,500 --> 01:14:56,730
through the same
red subnetwork, they

1051
01:14:56,730 --> 01:15:00,910
have to end up here in order to
go to both here and to there.

1052
01:15:00,910 --> 01:15:02,520
So we have congestion of two.

1053
01:15:02,520 --> 01:15:04,780
So what are those packets?

1054
01:15:04,780 --> 01:15:09,810
Well, what does pi map
to to one and five?

1055
01:15:09,810 --> 01:15:11,280
Let's look over here.

1056
01:15:11,280 --> 01:15:19,250
We see that pi 0 is equal
to 1 and pi 1 is equal to 5.

1057
01:15:19,250 --> 01:15:23,810
So packets zero and one are
actually mapped to output

1058
01:15:23,810 --> 01:15:25,710
one and five and
they should not go

1059
01:15:25,710 --> 01:15:29,490
both through the
same subnetwork.

1060
01:15:29,490 --> 01:15:32,132
So we have another
edge over here.

1061
01:15:32,132 --> 01:15:36,699
And now, we can continue this
and we have five and seven.

1062
01:15:36,699 --> 01:15:37,990
So just have a look over there.

1063
01:15:37,990 --> 01:15:42,320
See, five and seven, they map
to the outputs two and six.

1064
01:15:42,320 --> 01:15:44,650
Again, we have two and six.

1065
01:15:44,650 --> 01:15:47,900
If they are both mapped to
the same network, this one,

1066
01:15:47,900 --> 01:15:51,260
for example, then I
will have a problem.

1067
01:15:53,870 --> 01:15:57,950
So the other edge is over here.

1068
01:16:00,580 --> 01:16:02,070
So what did we do here?

1069
01:16:02,070 --> 01:16:05,810
We started to write out the
constraints on this side

1070
01:16:05,810 --> 01:16:10,580
and we wrote out the
constraints on this side.

1071
01:16:10,580 --> 01:16:12,770
So I only looked at
the red subnetwork.

1072
01:16:12,770 --> 01:16:13,920
That's what I realize now.

1073
01:16:13,920 --> 01:16:16,260
I could also have looked
at the blue network.

1074
01:16:16,260 --> 01:16:19,390
So let's do that also just
to make the picture complete.

1075
01:16:19,390 --> 01:16:24,010
So for example, let's look
at this particular example.

1076
01:16:24,010 --> 01:16:26,770
The packet six and
two should not both

1077
01:16:26,770 --> 01:16:29,560
be routed through
the blue network

1078
01:16:29,560 --> 01:16:32,150
because then they
would both have

1079
01:16:32,150 --> 01:16:34,980
to go through this
switch, one going up

1080
01:16:34,980 --> 01:16:40,300
to output zero and one going
to the right to output four.

1081
01:16:40,300 --> 01:16:43,670
So in order to avoid
congestion at all costs,

1082
01:16:43,670 --> 01:16:45,950
we have this constraint graph.

1083
01:16:45,950 --> 01:16:48,500
So now, we come to
the key insight.

1084
01:16:48,500 --> 01:16:53,030
And the key insight is to use
a two-coloring of this graph.

1085
01:16:57,060 --> 01:17:07,110
So the key insight
is a two-coloring

1086
01:17:07,110 --> 01:17:12,950
of the constraint
graph, which will

1087
01:17:12,950 --> 01:17:19,130
lead to a best solution
for the routing problem.

1088
01:17:19,130 --> 01:17:22,270
So let's do this.

1089
01:17:22,270 --> 01:17:25,220
So we will color this one blue.

1090
01:17:25,220 --> 01:17:28,210
As you can see, this
is an even cycle,

1091
01:17:28,210 --> 01:17:37,030
blue, red, blue, red,
and blue and red.

1092
01:17:37,030 --> 01:17:40,920
We will make this one
blue and this one red.

1093
01:17:40,920 --> 01:17:47,170
Well, it turns out that we can
now start our routing process.

1094
01:17:47,170 --> 01:17:52,660
So for example, actually,
I will draw a new graph

1095
01:17:52,660 --> 01:17:53,940
to make that really clear.

1096
01:18:03,640 --> 01:18:07,740
So I have my blue and
my red chalk over here

1097
01:18:07,740 --> 01:18:09,215
to demonstrate what I mean.

1098
01:18:12,520 --> 01:18:13,590
So what do I do?

1099
01:18:13,590 --> 01:18:19,970
I have zero, one, two, three,
four, five, six, and seven.

1100
01:18:19,970 --> 01:18:22,410
I have the switches that
correspond to those.

1101
01:18:26,390 --> 01:18:33,660
Well, if it's colored red-- so
zero over here is colored red--

1102
01:18:33,660 --> 01:18:35,535
I will direct it to
the red subnetwork.

1103
01:18:35,535 --> 01:18:38,810
So where is this red subnetwork?

1104
01:18:38,810 --> 01:18:48,800
It's really contained over
here and the blue one--

1105
01:18:48,800 --> 01:18:53,852
so this is the red one and
the blue one is right here.

1106
01:19:02,120 --> 01:19:09,320
And over here, we have the
outputs ranging from zero, one,

1107
01:19:09,320 --> 01:19:14,920
two, all the way to seven.

1108
01:19:14,920 --> 01:19:17,505
So input zero is colored red.

1109
01:19:17,505 --> 01:19:18,380
We go straight ahead.

1110
01:19:18,380 --> 01:19:20,550
We want to go to
the red network.

1111
01:19:20,550 --> 01:19:23,350
Input one is colored blue.

1112
01:19:23,350 --> 01:19:27,000
It goes, therefore,
to the blue network.

1113
01:19:27,000 --> 01:19:29,270
So this is the only
way how to do it.

1114
01:19:29,270 --> 01:19:31,640
Input two is colored red.

1115
01:19:31,640 --> 01:19:33,070
Go straight ahead.

1116
01:19:33,070 --> 01:19:35,330
Input three is also colored red.

1117
01:19:35,330 --> 01:19:36,670
Go straight ahead.

1118
01:19:36,670 --> 01:19:42,180
Input five-- oh, input
four is colored blue--

1119
01:19:42,180 --> 01:19:43,280
goes to the blue network.

1120
01:19:43,280 --> 01:19:48,620
Input five goes up
to the red network

1121
01:19:48,620 --> 01:19:52,680
and input six goes straight
ahead to the blue network.

1122
01:19:52,680 --> 01:19:57,280
It's colored blue and input
seven is also colored blue.

1123
01:19:57,280 --> 01:19:59,330
Let's look at the outputs.

1124
01:19:59,330 --> 01:20:06,445
So for example, well, let's
have a look at output zero.

1125
01:20:09,700 --> 01:20:15,650
so output zero-- which packet
is mapped to output zero?

1126
01:20:15,650 --> 01:20:19,570
It's packet number six.

1127
01:20:19,570 --> 01:20:23,830
So six was mapped
into the blue network

1128
01:20:23,830 --> 01:20:27,300
and then it needs to be
mapped to output zero.

1129
01:20:27,300 --> 01:20:29,380
So there's only
one edge that goes

1130
01:20:29,380 --> 01:20:33,350
from the blue network
to output zero, which

1131
01:20:33,350 --> 01:20:36,600
is this particular one.

1132
01:20:36,600 --> 01:20:38,800
And then somehow,
this one needs to be

1133
01:20:38,800 --> 01:20:42,490
mapped to this one over here.

1134
01:20:42,490 --> 01:20:44,800
Now, we can continue like this.

1135
01:20:44,800 --> 01:20:47,860
Output one should receives
a packet from-- let's look

1136
01:20:47,860 --> 01:20:50,710
at the permutation-- from five.

1137
01:20:50,710 --> 01:20:55,210
No, sorry, output one--
pi of 0 is equal to 1

1138
01:20:55,210 --> 01:20:58,770
so packet zero needs to go
to this particular output.

1139
01:20:58,770 --> 01:21:02,260
Now, packet zero is
in the red network

1140
01:21:02,260 --> 01:21:06,020
so there's only one edge that
goes from the red network

1141
01:21:06,020 --> 01:21:07,590
to this output.

1142
01:21:07,590 --> 01:21:10,710
So we need to have a
connection over here.

1143
01:21:10,710 --> 01:21:15,450
Now, we can continue this
and note and demonstrate--

1144
01:21:15,450 --> 01:21:17,000
and you can test
it for yourself,

1145
01:21:17,000 --> 01:21:19,880
too-- that output
four needs to receive

1146
01:21:19,880 --> 01:21:21,890
a packet from the red network.

1147
01:21:21,890 --> 01:21:25,180
Actually, it should be this
particular one, which happens

1148
01:21:25,180 --> 01:21:27,580
to be packet number two.

1149
01:21:27,580 --> 01:21:32,790
And then, we have
this one, right?

1150
01:21:32,790 --> 01:21:34,810
So let me just finish it.

1151
01:21:34,810 --> 01:21:47,350
We have this and we have these
two and we have this one.

1152
01:21:47,350 --> 01:21:53,970
We have this one and
we have this one.

1153
01:21:53,970 --> 01:21:57,480
This one goes straight ahead.

1154
01:21:57,480 --> 01:22:01,920
This one goes all the way up and
this one goes all the way up.

1155
01:22:01,920 --> 01:22:03,120
So what do we see?

1156
01:22:03,120 --> 01:22:08,750
We see that packets over
here, that these switches only

1157
01:22:08,750 --> 01:22:10,460
see a packet once
and these ones,

1158
01:22:10,460 --> 01:22:14,100
as well, these ones also
and these ones also.

1159
01:22:14,100 --> 01:22:19,890
So we have directed the
packets, routed the packets

1160
01:22:19,890 --> 01:22:24,050
to the red and the blue
subnetworks in such a way

1161
01:22:24,050 --> 01:22:29,920
that the congestion at the last
level and at the first level

1162
01:22:29,920 --> 01:22:31,680
is still equal to one.

1163
01:22:31,680 --> 01:22:34,150
Now, we use our
induction hypothesis

1164
01:22:34,150 --> 01:22:39,324
and we conclude that we
can map the route that's

1165
01:22:39,324 --> 01:22:41,240
going to have a routing
from packets from here

1166
01:22:41,240 --> 01:22:44,690
to here such that the congestion
within the subnetworks

1167
01:22:44,690 --> 01:22:50,930
is only one, so within the
blue as well as in the red.

1168
01:22:50,930 --> 01:22:55,530
So this is the insight into
how this works and I notice

1169
01:22:55,530 --> 01:22:56,950
I am running out of time.

1170
01:22:56,950 --> 01:23:01,460
So the formal proof we will have
to postpone until recitation,

1171
01:23:01,460 --> 01:23:05,890
but that's actually
really a very simple thing

1172
01:23:05,890 --> 01:23:07,540
to do that right now.

1173
01:23:07,540 --> 01:23:11,300
So just keep this
key insight and then

1174
01:23:11,300 --> 01:23:15,910
you can easily
prove the theorem.

1175
01:23:15,910 --> 01:23:18,820
But this is the real insight.

1176
01:23:18,820 --> 01:23:20,670
Thank you.